# Utility function to check if str is palindrome

def isPalindrome(string: str, low: int, high: int):
    while low < high:
        if string[low] != string[high]:
            return False
        low += 1
        high -= 1

    return True

# Recursive function to find all palindromic partitions of str[start..n-1]
# palindromic partitions of str[start..n-1]
# allPart --> A vector inside it stores a partition
# currPart --> A vector of strings to current partition


def allPalPartUtil(allPart: list, currPart: list, start: int, n: int, string: str):

    # If 'start' has reached len
    if start >= n:
        # in python lists are passed by reference
        # so copy is needed first
        x = currPart.copy()
        allPart.append(x)
        return

    # Pick all possible ending points for substrings
    for i in range(start, n):
        if isPalindrome(string, start, i):

            # Add the substring to result
            currPart.append(string[start:i + 1])

            # Recur for remaining substring
            allPalPartUtil(allPart, currPart, i + 1, n, string)

            currPart.pop()

# Function to print all possible
# Palindromic partitions of str
# It mainly creates vectors and
# calls allPalParUtils()


def allPalPartitions(string: str):
    n = len(string)

    # To Store all palindromic paritions
    allPart = []

    # To Store current palindromic partition
    currPart = []

    # Call recursive function to generate
    # all partitions and store in allPart
    allPalPartUtil(allPart, currPart, 0, n, string)
    # Print all partitions generated by above call
    for i in range(len(allPart)):
        for j in range(len(allPart[i])):
            print(allPart[i][j], end=" ")
        print()


# Driver Code
if __name__ == "__main__":

    string = "civic"
    print(allPalPartitions(string))
